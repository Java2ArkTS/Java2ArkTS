{
    "flag": 3,
    "ast_output": "public class WrongCounterDemo {\n\n    private static final int INC_COUNT = 100000000;\n\n    private volatile int counter = 0;\n\n    public static void main(String[] args) throws Exception {\n        WrongCounterDemo demo = new WrongCounterDemo();\n        System.out.println(\"Start task thread!\");\n        Thread thread1 = new Thread(demo.getConcurrencyCheckTask());\n        thread1.start();\n        Thread thread2 = new Thread(demo.getConcurrencyCheckTask());\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        int actualCounter = demo.counter;\n        int expectedCount = INC_COUNT * 2;\n        if (actualCounter != expectedCount) {\n            System.err.printf(\"Fuck! Got wrong count!! actual %s, expected: %s.%n\", actualCounter, expectedCount);\n        } else {\n            System.out.println(\"Wow... Got right count!\");\n        }\n    }\n\n    ConcurrencyCheckTask getConcurrencyCheckTask() {\n        return new ConcurrencyCheckTask();\n    }\n\n    //threadAble_class\n    private class ConcurrencyCheckTask implements Runnable {\n\n        @Override\n        @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n        public void run() {\n            for (int i = 0; i < INC_COUNT; ++i) {\n                ++counter;\n            }\n        }\n    }\n}\n",
    "classes": [
        {
            "class_index": 0,
            "class_code": "private class ConcurrencyCheckTask implements Runnable {\n\n    @Override\n    @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n    public void run() {\n        for (int i = 0; i < INC_COUNT; ++i) {\n            ++counter;\n        }\n    }\n}",
            "class_flag": 0
        },
        {
            "class_index": 1,
            "class_code": "public class WrongCounterDemo {\n\n    private static final int INC_COUNT = 100000000;\n\n    private volatile int counter = 0;\n\n    public static void main(String[] args) throws Exception {\n        WrongCounterDemo demo = new WrongCounterDemo();\n        System.out.println(\"Start task thread!\");\n        Thread thread1 = new Thread(demo.getConcurrencyCheckTask());\n        thread1.start();\n        Thread thread2 = new Thread(demo.getConcurrencyCheckTask());\n        thread2.start();\n        thread1.join();\n        thread2.join();\n        int actualCounter = demo.counter;\n        int expectedCount = INC_COUNT * 2;\n        if (actualCounter != expectedCount) {\n            System.err.printf(\"Fuck! Got wrong count!! actual %s, expected: %s.%n\", actualCounter, expectedCount);\n        } else {\n            System.out.println(\"Wow... Got right count!\");\n        }\n    }\n\n    ConcurrencyCheckTask getConcurrencyCheckTask() {\n        return new ConcurrencyCheckTask();\n    }\n\n    //threadAble_class\n    private class ConcurrencyCheckTask implements Runnable {\n\n        @Override\n        @SuppressWarnings(\"NonAtomicOperationOnVolatileField\")\n        public void run() {\n            for (int i = 0; i < INC_COUNT; ++i) {\n                ++counter;\n            }\n        }\n    }\n}",
            "class_flag": 1
        }
    ],
    "classnum": 2
}